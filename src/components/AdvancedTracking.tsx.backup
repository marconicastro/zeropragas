'use client';
import { useEffect, useRef } from 'react';
import META_CONFIG, { formatUserDataForMeta, validateMetaConfig } from '@/lib/metaConfig';
import { getAllTrackingParams, initializeTracking, getCachedGeographicData, getHighQualityLocationData, validateDataQuality } from '@/lib/cookies';
import { validateAndFixFacebookEvent, debugFacebookEvent } from '@/lib/facebookPixelValidation';

// --- FUN√á√ïES HELPER PARA O DATALAYER ---
// Fun√ß√£o para limpar dados removendo valores vazios e undefined
const cleanUserData = (userData: any) => {
  const cleaned = { ...userData };
  
  Object.keys(cleaned).forEach(key => {
    if (cleaned[key] === undefined || cleaned[key] === '' || cleaned[key] === null) {
      delete cleaned[key];
    }
  });
  
  return cleaned;
};

// Fun√ß√£o para limpar eventos processados antigos (mais de 24 horas)
const cleanupOldEvents = (): void => {
  if (typeof window === 'undefined') return;
  
  try {
    const processedEvents = JSON.parse(localStorage.getItem('fb_processed_events') || '[]');
    const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
    
    // Remover eventos mais antigos que 24 horas
    const recentEvents = processedEvents.filter((eventId: string) => {
      // Extrair timestamp do event_id (formato: timestamp + random)
      const timestamp = parseInt(eventId.split('.')[0], 36);
      return timestamp > twentyFourHoursAgo;
    });
    
    if (recentEvents.length !== processedEvents.length) {
      localStorage.setItem('fb_processed_events', JSON.stringify(recentEvents));
      console.log(`üßπ Limpos ${processedEvents.length - recentEvents.length} eventos antigos`);
    }
  } catch (error) {
    console.error('‚ùå Erro ao limpar eventos antigos:', error);
  }
};

// Fun√ß√£o para verificar se um evento j√° foi processado
const isEventProcessed = (eventId: string): boolean => {
  if (typeof window === 'undefined') return false;
  
  try {
    const processedEvents = JSON.parse(localStorage.getItem('fb_processed_events') || '[]');
    return processedEvents.includes(eventId);
  } catch (error) {
    console.error('‚ùå Erro ao verificar eventos processados:', error);
    return false;
  }
};

// Fun√ß√£o para marcar um evento como processado
const markEventAsProcessed = (eventId: string): void => {
  if (typeof window === 'undefined') return;
  
  try {
    const processedEvents = JSON.parse(localStorage.getItem('fb_processed_events') || '[]');
    if (!processedEvents.includes(eventId)) {
      processedEvents.push(eventId);
      // Manter apenas os √∫ltimos 100 eventos para evitar crescimento excessivo
      if (processedEvents.length > 100) {
        processedEvents.splice(0, processedEvents.length - 100);
      }
      localStorage.setItem('fb_processed_events', JSON.stringify(processedEvents));
    }
  } catch (error) {
    console.error('‚ùå Erro ao marcar evento como processado:', error);
  }
};

// Fun√ß√£o para gerar event_id √∫nico para desduplica√ß√£o
const generateEventId = (eventType: string = '') => {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substr(2, 9);
  return `${eventType}_${timestamp}_${random}`;
};

// Fun√ß√£o para calcular qualidade dos dados
const calculateDataQualityScore = (userData: any): number => {
  let score = 0;
  let maxScore = 0;
  
  // Pontuar dados de rastreamento (mais importantes)
  if (userData.fbc) score += 30;
  if (userData.fbp) score += 20;
  if (userData.external_id) score += 10;
  if (userData.ga_client_id) score += 10;
  
  // Pontuar dados de localiza√ß√£o
  if (userData.ct && userData.ct.length > 2) score += 10;
  if (userData.st && userData.st.length > 1) score += 10;
  if (userData.zp && userData.zp.length >= 8) score += 10;
  
  maxScore = 100; // Score m√°ximo poss√≠vel
  
  return Math.min(score, maxScore);
};

// Fun√ß√£o para obter dados de rastreamento melhorados
const getImprovedTrackingData = async () => {
  // Tentar obter dados de localiza√ß√£o de alta qualidade novamente
  const locationData = await getHighQualityLocationData();
  
  // Obter par√¢metros de rastreamento atualizados
  const trackingParams = await getAllTrackingParams();
  
  return {
    fbc: trackingParams.fbc,
    fbp: trackingParams.fbp,
    ga_client_id: trackingParams.ga_client_id,
    external_id: trackingParams.external_id,
    ct: locationData.city,
    st: locationData.state,
    zp: locationData.zip,
    country: locationData.country
  };
};

// Fun√ß√£o para esperar confirma√ß√£o de processamento do evento
const waitForServerSideConfirmation = async (eventId: string, timeout: number = 5000): Promise<boolean> => {
  if (typeof window === 'undefined') return false;
  
  return new Promise((resolve) => {
    const startTime = Date.now();
    
    const checkConfirmation = () => {
      const processedEvents = JSON.parse(localStorage.getItem('fb_server_confirmed_events') || '[]');
      
      if (processedEvents.includes(eventId)) {
        console.log(`‚úÖ Evento ${eventId} confirmado pelo server-side`);
        resolve(true);
        return;
      }
      
      if (Date.now() - startTime > timeout) {
        console.log(`‚è∞ Timeout aguardando confirma√ß√£o do evento ${eventId}`);
        resolve(false);
        return;
      }
      
      setTimeout(checkConfirmation, 100); // Verificar a cada 100ms
    };
    
    checkConfirmation();
  });
};

// Fun√ß√£o para marcar evento como confirmado pelo server-side
const markServerSideConfirmed = (eventId: string): void => {
  if (typeof window === 'undefined') return;
  
  try {
    const confirmedEvents = JSON.parse(localStorage.getItem('fb_server_confirmed_events') || '[]');
    if (!confirmedEvents.includes(eventId)) {
      confirmedEvents.push(eventId);
      // Manter apenas os √∫ltimos 50 eventos confirmados
      if (confirmedEvents.length > 50) {
        confirmedEvents.splice(0, confirmedEvents.length - 50);
      }
      localStorage.setItem('fb_server_confirmed_events', JSON.stringify(confirmedEvents));
    }
  } catch (error) {
    console.error('‚ùå Erro ao marcar evento como confirmado:', error);
  }
};

// Fun√ß√£o para enviar eventos com retry e valida√ß√£o de qualidade
const sendEventWithRetry = async (eventName: string, eventData: any, maxRetries = 3) => {
  let retries = 0;
  
  const attemptSend = async () => {
    try {
      // Validar qualidade dos dados antes de enviar com feedback detalhado
      const validation = validateDataQuality(eventData.user_data);
      
      if (META_CONFIG.TRACKING.enableDebugLogs) {
        console.log(`üìä Valida√ß√£o de dados para ${eventName}:`);
        console.log(`   - Score: ${validation.score}%`);
        console.log(`   - V√°lido: ${validation.isValid ? '‚úÖ' : '‚ùå'}`);
        if (validation.issues.length > 0) {
          console.log(`   - Issues: ${validation.issues.join(', ')}`);
        }
      }
      
      if (!validation.isValid && retries < maxRetries) {
        console.log(`üìä Qualidade insuficiente (${validation.score}%) para ${eventName}, tentando novamente... (${retries + 1}/${maxRetries})`);
        
        if (META_CONFIG.TRACKING.enableDebugLogs) {
          console.log(`üîß Recomenda√ß√µes para melhoria:`);
          validation.recommendations.forEach(rec => console.log(`   - ${rec}`));
        }
        
        retries++;
        
        // Esperar antes de tentar novamente (exponencial backoff)
        await new Promise(resolve => setTimeout(resolve, 1000 * retries));
        
        // Recalcular dados com melhor qualidade
        const improvedData = await getImprovedTrackingData();
        eventData.user_data = improvedData;
        
        return attemptSend();
      }
      
      // Enviar evento com dados de qualidade aceit√°vel
      const validatedEventData = validateAndFixFacebookEvent(eventData);
      debugFacebookEvent(eventName, validatedEventData);
      
      // Log detalhado dos dados antes de enviar
      console.log(`üì§ Enviando evento ${eventName} com dados limpos:`);
      console.log('üîë Event ID:', validatedEventData.event_id);
      console.log('üë§ User Data:', validatedEventData.user_data);
      console.log('üõçÔ∏è Custom Data:', validatedEventData.custom_data);
      
      window.dataLayer.push(validatedEventData);
      
      console.log(`‚úÖ Evento ${eventName} enviado com sucesso!`);
      console.log(`üìä Qualidade final: ${validation.score}%`);
      console.log(`üîë Event ID: ${eventData.event_id}`);
      
      if (META_CONFIG.TRACKING.enableDebugLogs) {
        console.log(`üìä Dados enviados para ${eventName}:`, eventData.user_data);
        
        // Log de sucesso com detalhes
        if (validation.score >= 90) {
          console.log(`üéâ EXCELENTE! Qualidade de dados acima de 90% para ${eventName}!`);
        } else if (validation.score >= 80) {
          console.log(`üëç √ìTIMO! Qualidade de dados acima de 80% para ${eventName}!`);
        } else if (validation.score >= 70) {
          console.log(`‚úÖ BOM! Qualidade de dados aceit√°vel para ${eventName}!`);
        }
      }
      
    } catch (error) {
      console.error(`‚ùå Erro ao enviar evento ${eventName}:`, error);
      if (retries < maxRetries) {
        retries++;
        console.log(`üîÑ Tentando novamente... (${retries}/${maxRetries})`);
        setTimeout(attemptSend, 1000 * retries);
      } else {
        console.error(`‚ùå Falha ao enviar evento ${eventName} ap√≥s ${maxRetries} tentativas`);
      }
    }
  };
  
  await attemptSend();
};

// Cada fun√ß√£o tem a responsabilidade √∫nica de enviar um evento padronizado para o dataLayer.

/**
 * Dispara o evento 'view_content' para o dataLayer com formato padronizado.
 * Utiliza uma trava para garantir que seja disparado apenas uma vez por p√°gina.
 * Inclui dados completos de localiza√ß√£o de alta qualidade e cookies do Facebook para melhor matching.
 */
const trackViewContent = async (viewContentHasBeenTracked) => {
  if (viewContentHasBeenTracked.current) {
    return; // Se j√° foi disparado, n√£o faz nada.
  }

  // Limpar eventos antigos antes de processar
  cleanupOldEvents();
  
  // Gerar event_id √∫nico para desduplica√ß√£o
  const eventId = generateEventId('view_content');
  
  // Verificar se este evento j√° foi processado (evita duplica√ß√£o entre recarregamentos de p√°gina)
  if (isEventProcessed(eventId)) {
    console.log('‚ö†Ô∏è ViewContent evento j√° processado anteriormente, pulando...');
    return;
  }
  
  // 1. Inicializar tracking primeiro
  await initializeTracking();
  
  // 2. Pequeno delay para garantir processamento do cookie FBC (AJUSTE PONTUAL)
  await new Promise(resolve => setTimeout(resolve, 100));
  
  // 3. Obter dados de localiza√ß√£o de ALTA QUALIDADE (prioridade formul√°rio > cache > API)
  const locationData = await getHighQualityLocationData();
  
  // 4. Obter todos os par√¢metros de rastreamento (incluindo FBC, FBP, etc.)
  const trackingParams = await getAllTrackingParams();
  
  // 5. Garantir captura do FBC - TENTATIVA AGRESSIVA
  let fbc = trackingParams.fbc;
  
  // Se n√£o tiver FBC, tentar capturar da URL novamente
  if (!fbc && typeof window !== 'undefined') {
    const urlParams = new URLSearchParams(window.location.search);
    const fbclid = urlParams.get('fbclid');
    
    if (fbclid) {
      // Criar FBC no formato correto
      const timestamp = Date.now();
      fbc = `fb.1.${timestamp}.${fbclid}`;
      
      // Salvar no cookie para futuros eventos
      const expirationDate = new Date();
      expirationDate.setDate(expirationDate.getDate() + 90);
      document.cookie = `_fbc=${fbc}; expires=${expirationDate.toUTCString()}; path=/; domain=${window.location.hostname}; SameSite=Lax`;
      
      console.log('üéØ FBC capturado e salvo no ViewContent:', fbc);
    }
  }
  
  // Se ainda n√£o tiver FBC, tentar obter do cookie novamente
  if (!fbc && typeof window !== 'undefined') {
    const fbcCookie = document.cookie.match(new RegExp('(^| )_fbc=([^;]+)'));
    if (fbcCookie) {
      fbc = fbcCookie[2];
      console.log('üéØ FBC obtido do cookie no ViewContent:', fbc);
    }
  }
  
  // Log do status do FBC para depura√ß√£o
  console.log('üìä Status FBC no ViewContent:', fbc ? '‚úÖ Presente' : '‚ùå Ausente');
  if (fbc) {
    console.log('üîë FBC value:', fbc);
  }
  
  // Usar o MESMO formato do InitiateCheckout para consist√™ncia
  const metaFormattedData = cleanUserData({
    // ‚úÖ Dados de rastreamento para matching (iguais ao InitiateCheckout)
    fbc: fbc, // Usar FBC garantido
    fbp: trackingParams.fbp,
    ga_client_id: trackingParams.ga_client_id,
    external_id: trackingParams.external_id,
    
    // ‚úÖ Dados geogr√°ficos no formato META (mesmo formato do InitiateCheckout)
    ct: locationData.city,
    st: locationData.state,
    zp: locationData.zip,
    country: locationData.country
  });
  
  // ESTRAT√âGIA DE ENVIO GARANTIDO: Server-side PRIMEIRO com confirma√ß√£o
  let serverSideSuccess = false;
  let serverSideConfirmed = false;
  
  // 1. TENTAR ENVIAR PARA SERVER-SIDE PRIMEIRO (prioridade m√°xima)
  if (typeof window !== 'undefined') {
    try {
      console.log('üöÄ Tentando enviar view_content para server-side (prioridade m√°xima)...');
      
      // Preparar dados no formato EXATO que o Facebook Pixel espera no server-side
      const serverSideData = {
        event_name: 'ViewContent', // Nome do evento padr√£o do Facebook
        event_id: eventId,
        pixel_id: '714277868320104', // ID do Pixel do Facebook
        user_data: {
          // Dados do usu√°rio no formato que o Facebook Pixel reconhece
          em: metaFormattedData.em,
          ph: metaFormattedData.ph,
          fn: metaFormattedData.fn,
          ln: metaFormattedData.ln,
          ct: metaFormattedData.ct,
          st: metaFormattedData.st,
          zp: metaFormattedData.zp,
          country: metaFormattedData.country,
          client_ip_address: '', // Ser√° preenchido pelo server-side
          client_user_agent: navigator.userAgent,
          fbc: metaFormattedData.fbc,
          fbp: metaFormattedData.fbp,
          external_id: metaFormattedData.external_id
        },
        custom_data: {
          currency: 'BRL',
          value: 39.90,
          content_name: 'Sistema de Controle de Trips - Maracuj√°',
          content_category: 'E-book',
          content_ids: ['6080425'], // ‚úÖ ARRAY CORRETO
          num_items: '1',
          contents: [{ // ‚úÖ ARRAY CORRETO
            id: '6080425',
            quantity: 1,
            item_price: 39.90
          }]
        }
      };
      
      console.log('üöÄ Dados view_content para server-side:', JSON.stringify(serverSideData, null, 2));
      
      // Enviar dados para o nosso server-side API
      const response = await fetch('/api/facebook-pixel', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(serverSideData)
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('‚úÖ ViewContent server-side enviado com sucesso!', result);
        serverSideSuccess = true;
        
        // Marcar o evento como enviado para evitar duplica√ß√£o futura
        markEventAsProcessed(eventId);
        
        // Executar script de confirma√ß√£o se estiver dispon√≠vel
        if (result.clientScript && typeof window !== 'undefined') {
          try {
            eval(result.clientScript);
            console.log('‚úÖ Script de confirma√ß√£o executado com sucesso');
          } catch (error) {
            console.error('‚ùå Erro ao executar script de confirma√ß√£o:', error);
          }
        }
        
        // Aguardar confirma√ß√£o de processamento (CR√çTICO para ordem correta)
        console.log('‚è≥ Aguardando confirma√ß√£o de processamento do server-side...');
        serverSideConfirmed = await waitForServerSideConfirmation(eventId, 3000); // 3 segundos de timeout
        
        if (serverSideConfirmed) {
          console.log('‚úÖ Server-side confirmado pelo Facebook - pulando client-side para evitar duplica√ß√£o');
          
          // Marcar eventos server-side como enviados para liberar GTM
          if (typeof window !== 'undefined' && window.markServerSideEventsSent) {
            window.markServerSideEventsSent();
          }
          
          // Liberar eventos bloqueados do Facebook Pixel
          if (typeof window !== 'undefined' && window._releaseBlockedEvents) {
            window._releaseBlockedEvents();
          }
        } else {
          console.log('‚ö†Ô∏è Server-side n√£o confirmado - client-side ser√° enviado como backup');
        }
        
      } else {
        console.error('‚ùå Falha no ViewContent server-side:', response.status, response.statusText);
        serverSideSuccess = false;
      }
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar ViewContent para server-side:', error);
      serverSideSuccess = false;
    }
  }

  // 2. ENVIAR PARA CLIENT-SIDE APENAS SE SERVER-SIDE FALHOU OU N√ÉO FOI CONFIRMADO
  if (!serverSideSuccess || !serverSideConfirmed) {
    if (!serverSideSuccess) {
      console.log('üîÑ ViewContent server-side falhou, usando fallback para client-side...');
    } else {
      console.log('üîÑ ViewContent server-side n√£o confirmado, enviando client-side como backup...');
    }
    
    // Delay estrat√©gico para garantir que o server-side tenha tempo de ser processado
    console.log('‚è≥ Aguardando 2 segundos antes de enviar client-side (garantir ordem correta)...');
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const eventData = {
      event: 'view_content',
      event_id: eventId, // Mesmo event_id para rastreamento
      custom_data: {
        currency: 'BRL',
        value: 39.90,
        content_name: 'Sistema de Controle de Trips - Maracuj√°',
        content_category: 'E-book',
        content_ids: ['6080425'], // ‚úÖ ARRAY CORRETO
        num_items: '1',
        contents: [{ // ‚úÖ ARRAY CORRETO
          id: '6080425',
          quantity: 1,
          item_price: 39.90
        }]
      },
      user_data: metaFormattedData
    };
    
    // Enviar com sistema de retry e valida√ß√£o de qualidade
    await sendEventWithRetry('view_content', eventData);
    
    console.log('‚úÖ ViewContent fallback client-side enviado com sucesso!');
  } else {
    console.log('‚úÖ ViewContent enviado e confirmado via server-side - client-side pulado para evitar duplica√ß√£o');
  }
  
  if (META_CONFIG.TRACKING.enableDebugLogs) {
    console.log('üéØ DataLayer Push: view_content (formato padronizado via GTM)');
    console.log('üîë Event ID:', eventId);
    console.log('üìç Dados de localiza√ß√£o (ALTA QUALIDADE):', locationData);
    console.log('üìä Dados formatados (META padr√£o):', metaFormattedData);
    console.log('‚úÖ Formato consistente com InitiateCheckout');
    console.log('üéØ FBC status:', fbc ? '‚úÖ Capturado' : '‚ùå N√£o encontrado');
  }
  
  viewContentHasBeenTracked.current = true; // Ativa a trava.
};

/**
 * Dispara o evento 'view_content' com dados do usu√°rio fornecidos.
 * @param {object} userData - Dados do usu√°rio para enriquecer o evento.
 */
const trackViewContentWithUserData = async (userData) => {
  // Limpar eventos antigos antes de processar
  cleanupOldEvents();
  
  // Gerar event_id √∫nico para desduplica√ß√£o
  const eventId = generateEventId('view_content');
  
  // Verificar se este evento j√° foi processado
  if (isEventProcessed(eventId)) {
    console.log('‚ö†Ô∏è ViewContent com userData j√° processado anteriormente, pulando...');
    return;
  }
  
  // 1. Inicializar tracking primeiro
  await initializeTracking();
  
  // 2. Obter dados de localiza√ß√£o de ALTA QUALIDADE
  const locationData = await getHighQualityLocationData();
  
  // 3. Obter todos os par√¢metros de rastreamento
  const trackingParams = await getAllTrackingParams();
  
  // 4. Garantir captura do FBC
  let fbc = trackingParams.fbc;
  
  // Se n√£o tiver FBC, tentar capturar da URL
  if (!fbc && typeof window !== 'undefined') {
    const urlParams = new URLSearchParams(window.location.search);
    const fbclid = urlParams.get('fbclid');
    
    if (fbclid) {
      const timestamp = Date.now();
      fbc = `fb.1.${timestamp}.${fbclid}`;
      
      const expirationDate = new Date();
      expirationDate.setDate(expirationDate.getDate() + 90);
      document.cookie = `_fbc=${fbc}; expires=${expirationDate.toUTCString()}; path=/; domain=${window.location.hostname}; SameSite=Lax`;
      
      console.log('üéØ FBC capturado e salvo no ViewContent com userData:', fbc);
    }
  }
  
  // Preparar dados no FORMATO META com dados do usu√°rio fornecidos
  const metaFormattedData = cleanUserData({
    // ‚úÖ Dados do usu√°rio fornecidos (alta qualidade)
    em: userData.email ? userData.email.toLowerCase().trim() : undefined,
    ph: userData.phone ? userData.phone.replace(/\D/g, '') : undefined,
    fn: userData.firstName ? userData.firstName.trim() : undefined,
    ln: userData.lastName ? userData.lastName.trim() : undefined,
    
    // ‚úÖ Dados geogr√°ficos
    ct: locationData.city || userData.city,
    st: locationData.state || userData.state,
    zp: locationData.zip || userData.zip,
    country: locationData.country || userData.country || 'BR',
    
    // ‚úÖ Dados de rastreamento
    fbc: fbc,
    fbp: trackingParams.fbp,
    ga_client_id: trackingParams.ga_client_id,
    external_id: userData.email ? userData.email.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() : trackingParams.external_id
  });
  
  // ESTRAT√âGIA DE ENVIO: Server-side com fallback Client-side
  let serverSideSuccess = false;
  
  // 1. TENTAR ENVIAR PARA SERVER-SIDE
  if (typeof window !== 'undefined') {
    try {
      console.log('üöÄ Tentando enviar view_content com userData para server-side...');
      
      const serverSideData = {
        event_name: 'ViewContent',
        event_id: eventId,
        pixel_id: '714277868320104',
        user_data: {
          em: metaFormattedData.em,
          ph: metaFormattedData.ph,
          fn: metaFormattedData.fn,
          ln: metaFormattedData.ln,
          ct: metaFormattedData.ct,
          st: metaFormattedData.st,
          zp: metaFormattedData.zp,
          country: metaFormattedData.country,
          client_ip_address: '',
          client_user_agent: navigator.userAgent,
          fbc: metaFormattedData.fbc,
          fbp: metaFormattedData.fbp,
          external_id: metaFormattedData.external_id
        },
        custom_data: {
          currency: 'BRL',
          value: 39.90,
          content_name: 'Sistema de Controle de Trips - Maracuj√°',
          content_category: 'E-book',
          content_ids: ['6080425'],
          num_items: '1',
          contents: [{
            id: '6080425',
            quantity: 1,
            item_price: 39.90
          }]
        }
      };
      
      const response = await fetch('/api/facebook-pixel', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(serverSideData)
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('‚úÖ ViewContent com userData server-side enviado com sucesso!', result);
        serverSideSuccess = true;
        markEventAsProcessed(eventId);
      } else {
        console.error('‚ùå Falha no ViewContent com userData server-side:', response.status);
        serverSideSuccess = false;
      }
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar ViewContent com userData para server-side:', error);
      serverSideSuccess = false;
    }
  }

  // 2. FALLBACK PARA CLIENT-SIDE
  if (!serverSideSuccess) {
    console.log('üîÑ ViewContent com userData server-side falhou, usando fallback client-side...');
    
    const eventData = {
      event: 'view_content',
      event_id: eventId,
      custom_data: {
        currency: 'BRL',
        value: 39.90,
        content_name: 'Sistema de Controle de Trips - Maracuj√°',
        content_category: 'E-book',
        content_ids: ['6080425'],
        num_items: '1',
        contents: [{
          id: '6080425',
          quantity: 1,
          item_price: 39.90
        }]
      },
      user_data: metaFormattedData
    };
    
    await sendEventWithRetry('view_content', eventData);
    console.log('‚úÖ ViewContent com userData fallback client-side enviado com sucesso!');
  }
  
  if (META_CONFIG.TRACKING.enableDebugLogs) {
    console.log('üéØ ViewContent com userData enviado com qualidade melhorada!');
    console.log('üìä Dados do usu√°rio inclu√≠dos:', {
      email: metaFormattedData.em ? '‚úÖ' : '‚ùå',
      phone: metaFormattedData.ph ? '‚úÖ' : '‚ùå',
      firstName: metaFormattedData.fn ? '‚úÖ' : '‚ùå',
      lastName: metaFormattedData.ln ? '‚úÖ' : '‚ùå'
    });
  }
};

/**
 * Dispara o evento 'initiate_checkout' com os dados do usu√°rio otimizados para Meta EQM.
 * @param {object} userData - Os dados capturados do formul√°rio de pr√©-checkout.
 */
const trackCheckout = async (userData) => {
  // Limpar eventos antigos antes de processar
  cleanupOldEvents();
  
  // Gerar event_id √∫nico e consistente com o mesmo padr√£o dos outros eventos
  const eventId = generateEventId('initiate_checkout');
  
  // Verificar se este evento j√° foi processado (evita duplica√ß√£o entre recarregamentos de p√°gina)
  if (isEventProcessed(eventId)) {
    console.log('‚ö†Ô∏è InitiateCheckout evento j√° processado anteriormente, pulando...');
    return;
  }
  
  // Obter dados de localiza√ß√£o de ALTA QUALIDADE (prioridade formul√°rio > cache > API)
  const locationData = await getHighQualityLocationData();
  
  // Preparar dados no FORMATO META que o Facebook reconhece - MELHORADO
  const metaFormattedData = cleanUserData({
    // ‚úÖ Dados do usu√°rio no formato que o Facebook entende
    em: userData.email ? userData.email.toLowerCase().trim() : undefined,           // Email - apenas se existir
    ph: userData.phone ? userData.phone.replace(/\D/g, '') : undefined,              // Telefone - apenas se existir
    fn: userData.firstName ? userData.firstName.trim() : undefined,                    // Primeiro nome - apenas se existir
    ln: userData.lastName ? userData.lastName.trim() : undefined,                     // Sobrenome - apenas se existir
    
    // ‚úÖ Dados geogr√°ficos - usar dados de ALTA QUALIDADE com fallback para formul√°rio
    ct: locationData.city || userData.city || undefined,           // Cidade - apenas se existir
    st: locationData.state || userData.state || undefined,          // Estado - apenas se existir
    zp: locationData.zip || userData.zip || undefined,            // CEP - apenas se existir
    country: locationData.country || userData.country || 'BR',     // Pa√≠s - sempre BR
    
    // ‚úÖ Dados de rastreamento para matching
    fbc: userData.fbc,
    fbp: userData.fbp,
    ga_client_id: userData.ga_client_id,
    external_id: userData.external_id
  });
  
  // Log detalhado para depura√ß√£o
  console.log('üåç Dados geogr√°ficos dispon√≠veis:');
  console.log('   - LocationData API:', locationData);
  console.log('   - LocationData Formul√°rio:', {
    city: userData.city,
    state: userData.state,
    zip: userData.zip,
    country: userData.country
  });
  console.log('üìß Dados do usu√°rio dispon√≠veis:');
  console.log('   - Email:', userData.email);
  console.log('   - Telefone:', userData.phone);
  console.log('   - Nome:', userData.firstName, userData.lastName);
  console.log('üîë Dados de rastreamento dispon√≠veis:');
  console.log('   - FBC:', userData.fbc);
  console.log('   - FBP:', userData.fbp);
  console.log('   - GA Client ID:', userData.ga_client_id);
  console.log('   - External ID:', userData.external_id);
  console.log('‚úÖ Dados finais ap√≥s limpeza:', metaFormattedData);
  
  // ESTRAT√âGIA DE ENVIO GARANTIDO: Server-side PRIMEIRO com confirma√ß√£o
  let serverSideSuccess = false;
  let serverSideConfirmed = false;
  
  // 1. TENTAR ENVIAR PARA SERVER-SIDE PRIMEIRO (prioridade m√°xima)
  if (typeof window !== 'undefined') {
    try {
      console.log('üöÄ Tentando enviar InitiateCheckout para server-side (prioridade m√°xima)...');
      
      // Preparar dados no formato EXATO que o Facebook Pixel espera no server-side
      const serverSideData = {
        event_name: 'InitiateCheckout', // Nome do evento padr√£o do Facebook
        event_id: eventId,
        pixel_id: '714277868320104', // ID do Pixel do Facebook
        user_data: {
          // Dados do usu√°rio no formato que o Facebook Pixel reconhece
          em: metaFormattedData.em,
          ph: metaFormattedData.ph,
          fn: metaFormattedData.fn,
          ln: metaFormattedData.ln,
          ct: metaFormattedData.ct,
          st: metaFormattedData.st,
          zp: metaFormattedData.zp,
          country: metaFormattedData.country,
          client_ip_address: '', // Ser√° preenchido pelo server-side
          client_user_agent: navigator.userAgent,
          fbc: metaFormattedData.fbc,
          fbp: metaFormattedData.fbp,
          external_id: metaFormattedData.external_id
        },
        custom_data: {
          currency: 'BRL',
          value: 39.90,
          content_name: 'E-book Sistema de Controle de Trips - Maracuj√°',
          content_category: 'E-book',
          content_ids: ['ebook-controle-trips'], // ‚úÖ ARRAY CORRETO
          num_items: '1',
          items: [{ // ‚úÖ ARRAY CORRETO
            item_id: 'ebook-controle-trips',
            item_name: 'E-book Sistema de Controle de Trips',
            quantity: 1,
            price: 39.90,
            item_category: 'E-book',
            item_brand: 'Maracuj√° Zero Pragas',
            currency: 'BRL'
          }]
        }
      };
      
      console.log('üöÄ Dados InitiateCheckout para server-side:', JSON.stringify(serverSideData, null, 2));
      
      // Enviar dados para o nosso server-side API
      const response = await fetch('/api/facebook-pixel', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(serverSideData)
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('‚úÖ InitiateCheckout server-side enviado com sucesso!', result);
        serverSideSuccess = true;
        
        // Marcar o evento como enviado para evitar duplica√ß√£o futura
        markEventAsProcessed(eventId);
        
        // Executar script de confirma√ß√£o se estiver dispon√≠vel
        if (result.clientScript && typeof window !== 'undefined') {
          try {
            eval(result.clientScript);
            console.log('‚úÖ Script de confirma√ß√£o executado com sucesso');
          } catch (error) {
            console.error('‚ùå Erro ao executar script de confirma√ß√£o:', error);
          }
        }
        
        // Aguardar confirma√ß√£o de processamento (CR√çTICO para ordem correta)
        console.log('‚è≥ Aguardando confirma√ß√£o de processamento do server-side...');
        serverSideConfirmed = await waitForServerSideConfirmation(eventId, 3000); // 3 segundos de timeout
        
        if (serverSideConfirmed) {
          console.log('‚úÖ Server-side confirmado pelo Facebook - pulando client-side para evitar duplica√ß√£o');
          
          // Marcar eventos server-side como enviados para liberar GTM
          if (typeof window !== 'undefined' && window.markServerSideEventsSent) {
            window.markServerSideEventsSent();
          }
          
          // Liberar eventos bloqueados do Facebook Pixel
          if (typeof window !== 'undefined' && window._releaseBlockedEvents) {
            window._releaseBlockedEvents();
          }
        } else {
          console.log('‚ö†Ô∏è Server-side n√£o confirmado - client-side ser√° enviado como backup');
        }
        
      } else {
        console.error('‚ùå Falha no InitiateCheckout server-side:', response.status, response.statusText);
        serverSideSuccess = false;
        
        // Liberar eventos bloqueados mesmo em caso de falha do servidor
        console.log('üîì Liberando eventos bloqueados devido √† falha do servidor...');
        if (typeof window !== 'undefined' && window.markServerSideEventsSent) {
          window.markServerSideEventsSent();
        }
        
        if (typeof window !== 'undefined' && window._releaseBlockedEvents) {
          window._releaseBlockedEvents();
        }
      }
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar InitiateCheckout para server-side:', error);
      serverSideSuccess = false;
      
      // Liberar eventos bloqueados mesmo em caso de erro/exce√ß√£o
      console.log('üîì Liberando eventos bloqueados devido √† exce√ß√£o no servidor...');
      if (typeof window !== 'undefined' && window.markServerSideEventsSent) {
        window.markServerSideEventsSent();
      }
      
      if (typeof window !== 'undefined' && window._releaseBlockedEvents) {
        window._releaseBlockedEvents();
      }
    }
  }

  // 2. ENVIAR PARA CLIENT-SIDE APENAS SE SERVER-SIDE FALHOU OU N√ÉO FOI CONFIRMADO
  if (!serverSideSuccess || !serverSideConfirmed) {
    if (!serverSideSuccess) {
      console.log('üîÑ InitiateCheckout server-side falhou, usando fallback para client-side...');
    } else {
      console.log('üîÑ InitiateCheckout server-side n√£o confirmado, enviando client-side como backup...');
    }
    
    // Delay estrat√©gico para garantir que o server-side tenha tempo de ser processado
    console.log('‚è≥ Aguardando 2 segundos antes de enviar client-side (garantir ordem correta)...');
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const eventData = {
      event: 'initiate_checkout',
      event_id: eventId, // Mesmo event_id para rastreamento
      custom_data: {
        currency: 'BRL',
        value: 39.90,
        content_name: 'E-book Sistema de Controle de Trips - Maracuj√°',
        content_category: 'E-book',
        content_ids: ['ebook-controle-trips'], // ‚úÖ ARRAY CORRETO
        num_items: '1',
        items: [{ // ‚úÖ ARRAY CORRETO
          item_id: 'ebook-controle-trips',
          item_name: 'E-book Sistema de Controle de Trips',
          quantity: 1,
          price: 39.90,
          item_category: 'E-book',
          item_brand: 'Maracuj√° Zero Pragas',
          currency: 'BRL'
        }]
      },
      user_data: metaFormattedData
    };
    
    // Enviar com sistema de retry e valida√ß√£o de qualidade
    await sendEventWithRetry('initiate_checkout', eventData);
    
    console.log('‚úÖ InitiateCheckout fallback client-side enviado com sucesso!');

  if (META_CONFIG.TRACKING.enableDebugLogs) {
    console.log('üõí Initiate Checkout: Enviado com formato OTIMIZADO para Facebook Pixel!');
    console.log('üîë Event ID:', eventId);
    console.log('üìä Dados formatados (META padr√£o):', metaFormattedData);
    console.log('üåç Dados geogr√°ficos usados:', locationData);
    console.log('üìà Ordem de envio: 1¬∞ Server-side, 2¬∞ Client-side (com 500ms de atraso)');
    console.log('üéØ Expectativa: Server-side deve ser priorizado e n√£o desduplicado!');
    
    // Log de confirma√ß√£o do formato correto
    console.log('üéØ Dados do formul√°rio enviados para Facebook Pixel:');
    console.log('   - Email (em):', metaFormattedData.em);
    console.log('   - Telefone (ph):', metaFormattedData.ph);
    console.log('   - Nome (fn):', metaFormattedData.fn);
    console.log('   - Sobrenome (ln):', metaFormattedData.ln);
    console.log('   - Cidade (ct):', metaFormattedData.ct);
    console.log('   - Estado (st):', metaFormattedData.st);
    console.log('   - CEP (zp):', metaFormattedData.zp);
    console.log('   - Pa√≠s (country):', metaFormattedData.country);
    console.log('   - FBC (fbc):', metaFormattedData.fbc);
    console.log('   - FBP (fbp):', metaFormattedData.fbp);
    console.log('   - External ID:', metaFormattedData.external_id);
    console.log('üöÄ Dados enviados: Server-side PRIMEIRO (prioridade), depois Client-side (backup)');
  }
};


// --- COMPONENTE PRINCIPAL ---
export default function AdvancedTracking() {
  // Cria a trava para o view_content, que persiste durante o ciclo de vida do componente.
  const viewContentHasBeenTracked = useRef(false);

  useEffect(() => {
    // Validar configura√ß√£o primeiro
    validateMetaConfig();
    
    // Inicializar captura de par√¢metros de rastreamento
    initializeTracking();
    
    // Log de inicializa√ß√£o unificada com melhorias
    if (META_CONFIG.TRACKING.enableDebugLogs) {
      console.log('üéØ AdvancedTracking: Inicializado com arquitetura OTIMIZADA!');
      console.log('üìä Todos os eventos (PageView, ViewContent, InitiateCheckout) usam apenas GTM');
      console.log('üîó Event ID padr√£o sincronizado entre todos os eventos');
      console.log('üåç Dados geogr√°ficos com ALTA QUALIDADE (formul√°rio > cache > API)');
      console.log('üéØ FBC: Sincronizado e garantido para todos os eventos');
      console.log('üîÑ Sistema de retry autom√°tico para qualidade de dados');
      console.log('üìà Valida√ß√£o detalhada de qualidade com feedback em tempo real');
      console.log('üöÄ Expectativa: Scores de qualidade EXCELENTES (8.0+) para todos os eventos!');
    }
    
    // Dispara o view_content ap√≥s o tempo configurado, mas apenas se a trava permitir.
    if (META_CONFIG.TRACKING.enableViewContent) {
      const timer = setTimeout(async () => {
        await trackViewContent(viewContentHasBeenTracked);
      }, META_CONFIG.TRACKING.viewContentDelay);

      // Expondo as fun√ß√µes na janela global para serem chamadas pelo pr√©-checkout.
      if (typeof window !== 'undefined') {
        window.advancedTracking = {
          // A fun√ß√£o trackCheckout √© exposta globalmente.
          trackCheckout,
          // A nova fun√ß√£o para ViewContent com dados do usu√°rio
          trackViewContentWithUserData,
        };
      }

      // Limpa o timer se o componente for desmontado.
      return () => clearTimeout(timer);
    }
  }, []);

  return null; // O componente n√£o renderiza nada na tela.
}

// --- TIPAGEM GLOBAL ---
// Garante que o TypeScript entenda o objeto window.advancedTracking.
declare global {
  interface Window {
    dataLayer?: any[];
    advancedTracking?: {
      trackCheckout: (userData: any) => Promise<void>;
      trackViewContentWithUserData: (userData: any) => Promise<void>;
    };
  }
}